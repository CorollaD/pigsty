#!/usr/bin/env patroni

######################################################################
# File      :   patroni.yml
# Mtime     :   2020-04-08
# Desc      :   patroni cluster definition for {{ pg_cluster }}
# Path      :   /pg/bin/patroni.yml
# Realpath  :   /pg/conf/{{ pg_instance }}.yml
# Author    :   Vonng(fengruohang@outlook.com)
# Note      :   /pg/bin/patroni.yml -> /pg/conf/{{ pg_instance}}.yml
# Doc       : https://patroni.readthedocs.io/en/latest/SETTINGS.html
######################################################################

---
namespace: {{ patroni_namespace }}/
scope:  {{ pg_cluster }}
name:   {{ pg_instance }}

log:
  level: INFO
  dir: /pg/log/

restapi:
  listen: 0.0.0.0:{{ patroni_port }}
  connect_address: {{ inventory_hostname }}:{{ patroni_port }}
  authentication:
    username: {{ pg_monitor_username }}
    password: {{ pg_monitor_password }}


{% if dcs_type == 'consul' %}
consul:
  host: 127.0.0.1:8500
  register_service: true
{% endif %}


postgresql:
  bin_dir: {{ pg_bin_dir }}
  data_dir: {{ pg_data }}
  # pgpass: /home/postgres/.pgpass

  listen:  0.0.0.0:{{ pg_port }}
  connect_address: {{ inventory_hostname }}:{{ pg_port }}

  use_pg_rewind: true
  remove_data_directory_on_rewind_failure: true

  authentication:
    superuser:
      username: {{ pg_dbsu }}
      password: {{ pg_dbsu_password }}
    replication:
      username: {{ pg_replication_username }}
      password: {{ pg_replication_password }}
    rewind:
      username: {{ pg_replication_username }}
      password: {{ pg_replication_password }}

  use_unix_socket: true
  parameters:
    unix_socket_directories: /var/run/postgresql

  # event callback
  callbacks:
    on_start:       /pg/bin/pg-failover-callback
    on_stop:        /pg/bin/pg-failover-callback
    on_role_change: /pg/bin/pg-failover-callback

  create_replica_methods:
    - basebackup
  basebackup:
    max-rate: '1000M'



bootstrap:
  # this section will be written into Etcd:/<namespace>/<scope>/config after initializing new cluster
  # and all other cluster members will use it as a `global configuration`

  initdb:
    - data-checksums
    - encoding: UTF8
    - locale: C

  pg_hba:
    - local   all             postgres                                ident
    - local   replication     postgres                                ident
    # allow intranet replication access
    - local   replication     replicator                              md5
    - host    replication     replicator          127.0.0.1/32        md5
    - host    replication     replicator          ::1/128             md5
    - host    replication     replicator          10.0.0.0/8          md5
    - host    replication     replicator          192.168.0.0/16      md5
    # allow local password access (including pgbouncer)
    - local   all     all                                             md5
    - host    all     all                         127.0.0.1/32        md5
    - host    all     all                         ::1/128             md5
    # allow intranet admin password access
    - host    all     +dbrole_admin               10.0.0.0/8          md5
    - host    all     +dbrole_admin               192.168.0.0/16      md5
    - # [reject|allow] intranet common user password access
    # ps: you can force using pgbouncer by rejecting direct access to db (comment 2 lines below)
    - host    all             all                 10.0.0.0/8          md5
    - host    all             all                 192.168.0.0/16      md5



  dcs:
    # IMPORTANT PARAMETERS
    # constraint: ttl >: loop_wait + retry_timeout * 2

    # the TTL to acquire the leader lock (in seconds). Think of it as the length of time before initiation of the automatic failover process. Default value: 30
    ttl: 30

    # the number of seconds the loop will sleep. Default value: 10
    loop_wait: 10

    # timeout for DCS and PostgreSQL operation retries (in seconds). DCS or network issues shorter than this will not cause Patroni to demote the leader. Default value: 10
    retry_timeout: 10

    # the amount of time a master is allowed to recover from failures before failover is triggered (in seconds)
    # Max RTO: 2 loop wait + master_start_timeout
    master_start_timeout: 300

    # import: candidate will not be promoted if replication lag is higher than this
    # maximum RPO: 1MB
    maximum_lag_on_failover: 1048576

    # turns on synchronous replication mode. In this mode a replica will be chosen as synchronous and only the latest leader and synchronous replica are able to participate in leader election
    # set to true for RPO mode
    synchronous_mode: false

    # prevents disabling synchronous replication if no synchronous replicas are available, blocking all client writes to the master
    synchronous_mode_strict: false

    postgresql:
      use_pg_rewind: true
      remove_data_directory_on_rewind_failure: true
      use_slots: true

      parameters:
        #------------------------------------------------------------------------------
        # IMPORTANT PARAMETERS
        #------------------------------------------------------------------------------
        max_connections: 200
        superuser_reserved_connections: 10
        max_locks_per_transaction: 128
        max_prepared_transactions: 0
        track_commit_timestamp: on
        max_worker_processes: 8
        wal_level: logical
        wal_log_hints: on
        max_wal_senders: 16
        max_replication_slots: 16
        wal_keep_segments: 1000
        password_encryption: md5

        #------------------------------------------------------------------------------
        # RESOURCE USAGE (except WAL)
        #------------------------------------------------------------------------------
        # memory: shared_buffers and maintenance_work_mem will be dynamically set
        shared_buffers: {{ pg_shared_buffers }}
        maintenance_work_mem: {{ pg_maintenance_work_mem }}
        work_mem: 32MB
        huge_pages: try
        temp_file_limit: 100GB
        vacuum_cost_delay: 5ms
        vacuum_cost_limit: 10000
        bgwriter_delay: 10ms
        bgwriter_lru_maxpages: 800
        bgwriter_lru_multiplier: 5.0

        #------------------------------------------------------------------------------
        # WAL
        #------------------------------------------------------------------------------
        wal_buffers: 16MB
        wal_writer_delay: 20ms
        wal_writer_flush_after: 1MB
        min_wal_size: 100GB
        max_wal_size: 500GB
        commit_delay: 20
        commit_siblings: 8
        checkpoint_timeout: 50min
        checkpoint_completion_target: 0.9
        recovery_target_timeline: 'latest'

        #------------------------------------------------------------------------------
        # REPLICATION
        #------------------------------------------------------------------------------
        # synchronous_standby_names: ''
        vacuum_defer_cleanup_age: 50000
        promote_trigger_file: 'promote.signal'
        max_standby_archive_delay: 10min        # max delay before canceling queries when reading WAL from archive;
        max_standby_streaming_delay: 3min       # max delay before canceling queries when reading streaming WAL;
        wal_receiver_status_interval: 1s        # send replies at least this often
        hot_standby_feedback: on                # send info from standby to prevent query conflicts
        wal_receiver_timeout: 60s               # time that receiver waits for
        max_logical_replication_workers: 10
        max_sync_workers_per_subscription: 10

        #------------------------------------------------------------------------------
        # QUERY TUNING
        #------------------------------------------------------------------------------
        # planner
        enable_partitionwise_join: on
        enable_partitionwise_aggregate: on
        random_page_cost: 1.1
        constraint_exclusion: partition
        effective_cache_size: 320GB
        default_statistics_target: 1000        # 100 -> 1000

        #------------------------------------------------------------------------------
        # REPORTING AND LOGGING
        #------------------------------------------------------------------------------
        log_destination: 'csvlog'
        logging_collector: on
        log_directory: 'log'
        log_filename: 'postgresql-%a.log'
        log_checkpoints: on
        log_lock_waits: on
        log_replication_commands: on
        log_statement: 'ddl'
        log_min_duration_statement: 100

        #------------------------------------------------------------------------------
        # STATISTICS
        #------------------------------------------------------------------------------
        track_io_timing: on
        track_functions: all                # none, pl, all
        track_activity_query_size: 4096    # (change requires restart)

        #------------------------------------------------------------------------------
        # AUTOVACUUM
        #------------------------------------------------------------------------------
        autovacuum: on
        log_autovacuum_min_duration: 1s
        autovacuum_max_workers: 3
        autovacuum_naptime: 30s
        autovacuum_vacuum_scale_factor: 0.05    # fraction of table size before vacuum
        autovacuum_analyze_scale_factor: 0.03    # fraction of table size before analyze
        autovacuum_vacuum_cost_delay: -1        # default vacuum cost delay for
        autovacuum_vacuum_cost_limit: -1        # default vacuum cost limit for

        #------------------------------------------------------------------------------
        # CLIENT
        #------------------------------------------------------------------------------
        search_path: 'yay, public'
        deadlock_timeout: 50ms
        idle_in_transaction_session_timeout: 600000        # 10min

        #------------------------------------------------------------------------------
        # CUSTOMIZED OPTIONS
        #------------------------------------------------------------------------------
        shared_preload_libraries: 'pg_stat_statements, auto_explain'

        # extension settings
        auto_explain.log_min_duration: 1min
        auto_explain.log_analyze: true
        auto_explain.log_verbose: true
        auto_explain.log_timing: true
        auto_explain.log_nested_statements: true
        pg_stat_statements.max: 10000
        pg_stat_statements.track: all



watchdog:
  mode: automatic
  device: {{ patroni_watchdog_path }}


tags:
  nofailover: false
  clonefrom: true
  noloadbalance: false
  nosync: false
  {% if pg_upstream is defined %}
replicatefrom: {{ pg_upstream }}
  {% endif %}